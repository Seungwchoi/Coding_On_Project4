# 네트워크 통신을 이용한 실시간 채팅 프로그램 📨  
> 실시간 채팅 확인과 그룹 유저들의 채팅 기능 구현

---

## 📝 프로젝트 소개

- **주제**  
  C++를 기반으로 TCP 소켓을 활용한 서버-클라이언트 구조의 실시간 채팅 시스템 개발.

- **기획 의도**  
  네트워크 프로그래밍과 멀티스레딩에 대한 이해를 바탕으로 실시간 통신 시스템의 구조를 직접 설계하고 구현함으로써, 소켓 통신, 스레드 처리, 서버 관리 등 시스템 프로그래밍의 실무 감각을 익히기 위함.

- **기간**  
  📅 2025.04.16 ~ 2025.04.24 (총 9일)

---
## 💡 프로젝트 시행 영상

![채팅프로그램시연영상](https://github.com/user-attachments/assets/105baab1-98e4-43cf-ba69-e7b7fafd1cd7)
![채팅프로그램시연영상](https://github.com/user-attachments/assets/105baab1-98e4-43cf-ba69-e7b7fafd1cd7)



## 🛠️ 사용한 기술

| 기술명                | 내용                                           |
|----------------------|------------------------------------------------|
| C++                  | 전체 시스템 로직 및 네트워크 처리             |
| WinSock2             | 윈도우 기반 TCP 소켓 통신 구현                |
| Thread (`std::thread`) | 클라이언트별 멀티 스레드 채팅 처리           |
| STL (`vector`, `map`, `mutex`) | 클라이언트 관리 및 동기화 처리      |
| Signal (`signal.h`)  | Ctrl+C 입력 시 안전한 서버 종료 제어          |

---

## 💡 주요 기술 채택 이유

- **WinSock2**  
  윈도우 환경에서의 소켓 프로그래밍 표준으로, TCP 기반의 안정적인 통신 구현을 위해 선택함.

- **멀티스레딩 (`std::thread`)**  
  각 클라이언트를 별도 스레드로 처리하여 비동기 수신이 가능하도록 구현. 이를 통해 동시에 여러 사용자와의 채팅이 가능해짐.

- **STL 자료구조 사용**  
  `vector`, `map`, `mutex` 등을 사용하여 클라이언트 소켓 관리 및 닉네임 매핑, 동기화 처리 등을 효율적으로 구현.

---

## 📌 추가 기술 상세 설명

- **멀티 스레딩**  
  `std::thread`, `std::mutex`를 사용하여 각 클라이언트의 메시지 수신을 독립적으로 처리.  
  서버는 동시에 여러 클라이언트와 실시간 통신이 가능하도록 설계됨.

- **클라이언트 동기화**  
  `std::mutex`와 `std::lock_guard`를 사용하여 `client_sockets` 및 `client_names`에 대한 쓰레드 동기화 처리.  
  클라이언트 수 추가/삭제 시 데이터 충돌 방지.

- **신호 처리 (Graceful Shutdown)**  
  `signal(SIGINT, handler)` 구문을 사용해 `Ctrl+C` 입력 시 서버가 전체 클라이언트에게 종료 메시지를 전송하고 리소스를 정리하며 종료하도록 구현함.

- **데이터 구조**  
  `std::vector`를 이용하여 클라이언트 소켓 목록을 관리하고,  
  `std::map<SOCKET, std::string>`을 사용해 소켓과 닉네임을 매핑하여 사용자의 구분이 가능하도록 구현함.

---

## 🙋‍♂️ 내가 구현한 기능

-  **실시간 그룹 채팅 기능**  
  → 하나의 메시지를 모든 클라이언트에게 브로드캐스트 전송

-  **닉네임 등록 및 출력**  
  → 클라이언트 최초 접속 시 닉네임을 등록하고 메시지 전송 시 닉네임을 함께 표시

-  **멀티 클라이언트 동시 접속 처리**  
  → `std::thread`를 통해 클라이언트별 독립된 채팅 세션 제공

-  **접속 인원 수 확인 및 제한**  
  → 최대 8명까지의 동시 접속 허용 (이상 접속 시 메시지 전송 후 연결 차단)

-  **서버 종료 시 전체 공지 및 안전 종료 처리**  
  → `Ctrl+C` 입력 시 모든 클라이언트에게 종료 메시지 전송 후 정리

-  **사용 가능한 포트 자동 탐색**  
  → 지정된 포트 범위 내에서 사용 가능한 포트를 자동 탐색하여 바인딩

---

## ✅ 주요 구현 기능 요약

- **클라이언트 접속 관리**
  - 최대 8명의 클라이언트 동시 접속 지원
  - 초과 접속 시 연결 거부 및 안내 메시지 전송

- **자동 포트 할당**
  - 지정된 포트 범위(15410 ~ 33333) 내에서 사용 가능한 포트를 자동 탐색 및 할당

- **멀티스레딩 기반 클라이언트 처리**
  - 각 클라이언트 연결에 대해 독립적인 `std::thread`로 통신 처리

- **메시지 브로드캐스트**
  - 한 클라이언트가 보낸 메시지를 모든 다른 클라이언트에게 실시간 전송

- **서버 종료 제어**
  - `Ctrl + C` 입력 시 서버 종료 신호 처리
  - 종료 전 모든 클라이언트에게 알림 메시지 전송 및 소켓 정리

- **에러 처리 및 로그 출력**
  - 클라이언트의 비정상 종료(예: 네트워크 오류, 강제 종료 등)를 감지
  - 서버 콘솔에 로그 메시지 출력하여 상태 모니터링 가능

---

## 🗃️ 프로그램 흐름도

```
┌────────────┐        TCP         ┌─────────────┐
│ ChatClient ───────────────────────▶  C++ 서버 │
└────────────┘                    └─────────────┘
       │
  GUI (tkinter)
       │
┌──────▼─────┐
│LoginFrame  │    ←→  users.json 파일 (로그인/회원가입)
└────────────┘
```


---

## 🧠 느낀점 및 회고

이번 프로젝트를 통해 평소 이론으로만 접하던 **소켓 통신**과 **멀티스레딩**을 실제 코드로 구현하면서 **네트워크 프로그래밍의 흐름**을 구체적으로 체감할 수 있었습니다.

특히 다음과 같은 점에서 서버와 클라이언트부분의 이해도가 많이 늘었습니다:

- 🔄 **서버-클라이언트 구조의 흐름**  
  요청 → 수락 → 응답 → 브로드캐스트라는 구조적 흐름을 직접 코드로 구현하며, 데이터가 어떤 방식으로 오고 가는지를 명확하게 이해할 수 있었습니다.

- 🧵 **멀티스레드 처리의 중요성**  
  단일 스레드에서는 여러 클라이언트의 동시 처리가 불가능하다는 것을 실습을 통해 깨달았고, `std::thread`를 이용한 병렬 처리를 구현하며 스레드 안전성(`mutex`)에 대해서도 학습했습니다.

- ⚠️ **에러 처리와 리소스 관리의 필요성**  
  비정상 종료나 예외 상황에서 서버가 안정적으로 클라이언트를 종료하고 리소스를 회수해야 한다는 점을 구현하면서 **실제 시스템에서의 견고함**이 얼마나 중요한지를 실감했습니다.

- 💬 **사용자 경험(UX) 요소 고려**  
  닉네임 입력, 접속 인원 안내, 서버 종료 공지 등 실제 사용자를 고려한 요소들을 추가하면서 단순한 기술 구현을 넘어 **완성도 있는 프로그램**으로 발전시킬 수 있었습니다.

- 📝 **개선할 점이나 보완할 점**  
  다양한 부가기능 도입(예: 동영상, 이미지, 파일 전송 등)을 고려할 때, 시스템 구조의 확장성 확보를 위한 전반적인 개선이 필요합니다. 또한, 네트워크 장애 발생 시 적절한 대응이 부족하고 보안성 또한 취약해 보입니다. 이에 따라 보안 강화와 함께 재연결 메커니즘 도입 등의 안정성 확보 방안을 마련해야 할 것입니다.

이번 프로젝트를 계기로 단순한 콘솔 프로그램을 넘어서 **실제 서비스 가능한 채팅 시스템**으로 발전시키기 위해 고려할 점들 (예: GUI, 파일 전송, 메시지 로그 저장 등)에 대한 방향성도 잡을 수 있었습니다.
